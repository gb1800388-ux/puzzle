<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ü–∞–∑–ª–æ–≤ Pro - –ß–ü–£ –∏ –ü–µ—á–∞—Ç—å</title>
    <style>
        :root {
            --primary: #4f46e5;
            --primary-dark: #4338ca;
            --secondary: #64748b;
            --bg-light: #f8fafc;
            --surface: #ffffff;
            --border: #e2e8f0;
            --text-main: #1e293b;
            --text-light: #64748b;
            --success: #10b981;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f1f5f9;
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        h1 { font-size: 1.25rem; font-weight: 700; color: var(--primary-dark); display: flex; align-items: center; gap: 10px; }
        .badge { background: var(--primary); color: white; font-size: 0.75rem; padding: 2px 8px; border-radius: 12px; text-transform: uppercase; letter-spacing: 0.5px; }

        /* Main Layout */
        main {
            display: grid;
            grid-template-columns: 320px 1fr;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar Controls */
        aside {
            background: var(--surface);
            border-right: 1px solid var(--border);
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
        .control-group label { font-size: 0.875rem; font-weight: 600; color: var(--text-main); }
        .control-desc { font-size: 0.75rem; color: var(--text-light); margin-bottom: 0.25rem; }

        /* Upload Box */
        .upload-box {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 2rem 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-light);
            position: relative;
            overflow: hidden;
        }
        .upload-box:hover { border-color: var(--primary); background: #eef2ff; }
        .upload-box input { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
        .upload-preview { max-width: 100%; max-height: 120px; display: none; margin: 0 auto; border-radius: 4px; box-shadow: var(--shadow); }

        /* Inputs & Selects */
        select, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
        }
        input:focus, select:focus { outline: 2px solid var(--primary); border-color: transparent; }

        /* Radio Cards */
        .radio-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .radio-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .radio-card { position: relative; }
        .radio-card input { position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
        .radio-content {
            border: 2px solid var(--border);
            border-radius: 6px;
            padding: 0.75rem 0.25rem;
            text-align: center;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .radio-card input:checked + .radio-content { border-color: var(--primary); background: #eef2ff; color: var(--primary-dark); }

        /* Range Slider */
        .range-container { display: flex; flex-direction: column; gap: 8px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: var(--primary); }
        .range-value { font-size: 0.85rem; font-weight: 600; color: var(--primary); text-align: right; }

        /* Buttons */
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        .btn-primary { background: var(--primary); color: white; width: 100%; box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.3); }
        .btn-primary:hover { background: var(--primary-dark); transform: translateY(-1px); }
        .btn-primary:active { transform: translateY(0); }

        /* Preview Area */
        .preview-area {
            background: #e2e8f0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: auto;
        }

        #canvas-container {
            background: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border);
        }

        canvas { display: block; }

        /* Floating Actions */
        .actions-bar {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: white;
            padding: 0.5rem;
            border-radius: 12px;
            display: flex;
            gap: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .action-btn {
            width: 44px; height: 44px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: white;
            color: var(--text-main);
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
            position: relative;
        }
        .action-btn:hover { background: var(--bg-light); color: var(--primary); border-color: var(--primary); }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .action-btn svg { width: 20px; height: 20px; }

        /* Tooltip */
        .action-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e293b;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .action-btn:hover::after { opacity: 1; }

        /* Toast Notification */
        .toast {
            position: fixed; top: 20px; right: 20px;
            background: white; border-left: 4px solid var(--success);
            padding: 1rem 1.5rem; border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
            transform: translateX(150%); transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            z-index: 1000; font-size: 0.9rem; font-weight: 500;
        }
        .toast.show { transform: translateX(0); }

        /* Placeholder text */
        .placeholder-text {
            color: var(--text-light);
            text-align: center;
            font-size: 0.9rem;
        }

        @media (max-width: 900px) {
            main { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            aside { max-height: 45vh; }
            .actions-bar { bottom: 1rem; right: 1rem; }
        }
    </style>
</head>
<body>

<header>
    <h1>
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
        –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ü–∞–∑–ª–æ–≤ <span class="badge">Pro</span>
    </h1>
    <div style="font-size: 0.8rem; color: var(--text-light);">–î–ª—è –ø–µ—á–∞—Ç–∏ –∏ –ß–ü–£ —Ä–µ–∑–∫–∏</div>
</header>

<main>
    <aside>
        <div class="control-group">
            <div class="control-desc">1. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</div>
            <div class="upload-box" id="dropZone">
                <input type="file" id="fileInput" accept="image/*">
                <div id="uploadPlaceholder">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                    <div style="margin-top:8px; font-size:0.9rem;">–ù–∞–∂–º–∏—Ç–µ –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ</div>
                </div>
                <img id="imagePreview" class="upload-preview" alt="Preview">
            </div>
        </div>

        <div class="control-group">
            <label>–§–æ—Ä–º–∞—Ç –±—É–º–∞–≥–∏</label>
            <div class="radio-grid">
                <div class="radio-card">
                    <input type="radio" name="paper" value="a4" checked>
                    <div class="radio-content">A4<br><small style="opacity:0.7">297√ó210</small></div>
                </div>
                <div class="radio-card">
                    <input type="radio" name="paper" value="a3">
                    <div class="radio-content">A3<br><small style="opacity:0.7">420√ó297</small></div>
                </div>
            </div>
        </div>

        <div class="control-group">
            <label>–¢–∏–ø –ø–∞–∑–ª–∞</label>
            <div class="radio-grid">
                <div class="radio-card">
                    <input type="radio" name="type" value="classic" checked>
                    <div class="radio-content">üß© –ö–ª–∞—Å—Å–∏–∫–∞</div>
                </div>
                <div class="radio-card">
                    <input type="radio" name="type" value="square">
                    <div class="radio-content">‚¨ú –ö–≤–∞–¥—Ä–∞—Ç—ã</div>
                </div>
            </div>
            <div class="control-desc">"–ö–ª–∞—Å—Å–∏–∫–∞" - –∑–∞–º–∫–∏ –∫–∞–∫ –≤ JigsawPlanet</div>
        </div>

        <div class="control-group">
            <label>–°–ª–æ–∂–Ω–æ—Å—Ç—å</label>
            <div class="range-container">
                <input type="range" id="difficulty" min="1" max="10" value="3" step="1">
                <div class="range-value" id="piecesInfo">12 –¥–µ—Ç–∞–ª–µ–π (4√ó3)</div>
            </div>
        </div>

        <div class="control-group">
            <label>–û—Ç—Å—Ç—É–ø –æ—Ç –∫—Ä–∞—è (–º–º)</label>
            <input type="number" id="bleed" value="5" min="0" max="30">
            <div class="control-desc">–ü–æ–ª–µ –¥–ª—è –ø—Ä–∏–∂–∏–º–∞ –Ω–∞ –ß–ü–£</div>
        </div>

        <div class="control-group">
            <label>–¢–æ–ª—â–∏–Ω–∞ –ª–∏–Ω–∏–∏ —Ä–µ–∑–∞ (px)</label>
            <input type="number" id="strokeWidth" value="1.5" min="0.5" max="5" step="0.5">
        </div>

        <div style="margin-top: auto;">
            <button class="btn btn-primary" id="generateBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–∞–∑–ª
            </button>
        </div>
    </aside>

    <div class="preview-area">
        <div id="canvas-container">
            <canvas id="puzzleCanvas"></canvas>
        </div>
        <p class="placeholder-text" id="placeholderText">–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã</p>
    </div>
</main>

<div class="actions-bar">
    <button class="action-btn" id="btnSavePNG" data-tooltip="PNG —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π" disabled>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
    </button>
    <button class="action-btn" id="btnSaveSVG" data-tooltip="SVG –≤–µ–∫—Ç–æ—Ä" disabled>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
    </button>
    <button class="action-btn" id="btnSaveDXF" data-tooltip="DXF –¥–ª—è –ß–ü–£" disabled>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
    </button>
    <button class="action-btn" id="btnSaveCutLines" data-tooltip="–¢–æ–ª—å–∫–æ –∫–æ–Ω—Ç—É—Ä—ã PNG" disabled>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></svg>
    </button>
</div>

<div id="toast" class="toast">–ì–æ—Ç–æ–≤–æ!</div>

<script>
/**
 * ============================================
 * –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ü–∞–∑–ª–æ–≤ Pro
 * ============================================
 */

const CONFIG = {
    DPI: 96,
    MM_TO_PX: 96 / 25.4,
    PAPER: {
        a4: { w: 297, h: 210 }, // Landscape
        a3: { w: 420, h: 297 }
    },
    DIFFICULTY: [
        { cols: 2, rows: 2 },   // 1: 4
        { cols: 3, rows: 2 },   // 2: 6
        { cols: 4, rows: 3 },   // 3: 12
        { cols: 5, rows: 4 },   // 4: 20
        { cols: 6, rows: 4 },   // 5: 24
        { cols: 7, rows: 5 },   // 6: 35
        { cols: 8, rows: 6 },   // 7: 48
        { cols: 10, rows: 7 },  // 8: 70
        { cols: 12, rows: 8 },  // 9: 96
        { cols: 15, rows: 10 }  // 10: 150
    ]
};

class PuzzleGenerator {
    constructor() {
        this.canvas = document.getElementById('puzzleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.image = null;
        this.puzzleData = null;
        this.seed = Date.now();

        this.state = {
            paper: 'a4',
            type: 'classic',
            difficulty: 3,
            bleed: 5,
            strokeWidth: 1.5
        };

        this.init();
    }

    // Seeded random for reproducible puzzles
    random() {
        this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
        return this.seed / 0x7fffffff;
    }

    init() {
        // File upload
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');

        fileInput.addEventListener('change', e => {
            if (e.target.files[0]) this.loadImage(e.target.files[0]);
        });

        dropZone.addEventListener('dragover', e => {
            e.preventDefault();
            dropZone.style.borderColor = 'var(--primary)';
            dropZone.style.background = '#eef2ff';
        });

        dropZone.addEventListener('dragleave', e => {
            e.preventDefault();
            dropZone.style.borderColor = '';
            dropZone.style.background = '';
        });

        dropZone.addEventListener('drop', e => {
            e.preventDefault();
            dropZone.style.borderColor = '';
            dropZone.style.background = '';
            if (e.dataTransfer.files[0]) this.loadImage(e.dataTransfer.files[0]);
        });

        // Controls
        document.querySelectorAll('input[name="paper"]').forEach(el => {
            el.addEventListener('change', e => { this.state.paper = e.target.value; this.generate(); });
        });

        document.querySelectorAll('input[name="type"]').forEach(el => {
            el.addEventListener('change', e => { this.state.type = e.target.value; this.generate(); });
        });

        document.getElementById('difficulty').addEventListener('input', e => {
            this.state.difficulty = parseInt(e.target.value);
            this.updatePiecesLabel();
            if (this.image) this.generate();
        });

        document.getElementById('bleed').addEventListener('change', e => {
            this.state.bleed = parseFloat(e.target.value) || 5;
            if (this.image) this.generate();
        });

        document.getElementById('strokeWidth').addEventListener('change', e => {
            this.state.strokeWidth = parseFloat(e.target.value) || 1.5;
            if (this.image) this.generate();
        });

        // Buttons
        document.getElementById('generateBtn').addEventListener('click', () => this.generate());
        document.getElementById('btnSavePNG').addEventListener('click', () => this.exportPNG(true));
        document.getElementById('btnSaveCutLines').addEventListener('click', () => this.exportPNG(false));
        document.getElementById('btnSaveSVG').addEventListener('click', () => this.exportSVG());
        document.getElementById('btnSaveDXF').addEventListener('click', () => this.exportDXF());

        this.updatePiecesLabel();
    }

    updatePiecesLabel() {
        const grid = this.getGrid();
        const total = grid.cols * grid.rows;
        document.getElementById('piecesInfo').textContent = `${total} –¥–µ—Ç–∞–ª–µ–π (${grid.cols}√ó${grid.rows})`;
    }

    getGrid() {
        const base = CONFIG.DIFFICULTY[this.state.difficulty - 1] || CONFIG.DIFFICULTY[2];

        if (!this.image) return base;

        const imgAspect = this.image.width / this.image.height;

        // –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º —Å–µ—Ç–∫—É –ø–æ–¥ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω
        if (imgAspect > 1.3) {
            return { cols: Math.max(base.cols, base.rows), rows: Math.min(base.cols, base.rows) };
        } else if (imgAspect < 0.77) {
            return { cols: Math.min(base.cols, base.rows), rows: Math.max(base.cols, base.rows) };
        }

        return base;
    }

    loadImage(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                this.image = img;

                // Preview
                const preview = document.getElementById('imagePreview');
                preview.src = img.src;
                preview.style.display = 'block';
                document.getElementById('uploadPlaceholder').style.display = 'none';
                document.getElementById('placeholderText').style.display = 'none';

                this.updatePiecesLabel();
                this.generate();
                this.toast('–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ!');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    generate() {
        if (!this.image) return;

        this.seed = Date.now();

        const paper = CONFIG.PAPER[this.state.paper];
        const bleedPx = this.state.bleed * CONFIG.MM_TO_PX;

        // Canvas size
        const canvasW = paper.w * CONFIG.MM_TO_PX;
        const canvasH = paper.h * CONFIG.MM_TO_PX;

        this.canvas.width = canvasW;
        this.canvas.height = canvasH;

        // Available area
        const availW = canvasW - bleedPx * 2;
        const availH = canvasH - bleedPx * 2;

        // Fit image
        const imgAspect = this.image.width / this.image.height;
        const areaAspect = availW / availH;

        let imgW, imgH;
        if (imgAspect > areaAspect) {
            imgW = availW;
            imgH = availW / imgAspect;
        } else {
            imgH = availH;
            imgW = availH * imgAspect;
        }

        const posX = (canvasW - imgW) / 2;
        const posY = (canvasH - imgH) / 2;

        // Generate puzzle paths
        const grid = this.getGrid();
        this.puzzleData = this.createPuzzle(grid.cols, grid.rows, imgW, imgH, posX, posY);

        // Render
        this.render();
        this.enableButtons();
    }

    createPuzzle(cols, rows, w, h, offsetX, offsetY) {
        const pieces = [];
        const pieceW = w / cols;
        const pieceH = h / rows;
        const tabSize = Math.min(pieceW, pieceH) * 0.22;

        // Generate tab directions
        const hTabs = []; // Horizontal edges (between rows)
        const vTabs = []; // Vertical edges (between cols)

        for (let r = 0; r < rows - 1; r++) {
            hTabs[r] = [];
            for (let c = 0; c < cols; c++) {
                hTabs[r][c] = this.random() > 0.5 ? 1 : -1;
            }
        }

        for (let r = 0; r < rows; r++) {
            vTabs[r] = [];
            for (let c = 0; c < cols - 1; c++) {
                vTabs[r][c] = this.random() > 0.5 ? 1 : -1;
            }
        }

        // Create pieces
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const x = offsetX + c * pieceW;
                const y = offsetY + r * pieceH;

                const top = r > 0 ? -hTabs[r - 1][c] : 0;
                const right = c < cols - 1 ? vTabs[r][c] : 0;
                const bottom = r < rows - 1 ? hTabs[r][c] : 0;
                const left = c > 0 ? -vTabs[r][c - 1] : 0;

                const path = this.createPiecePath(x, y, pieceW, pieceH, tabSize, top, right, bottom, left);
                pieces.push({ path, x, y, w: pieceW, h: pieceH, row: r, col: c });
            }
        }

        // Border path
        const borderPath = `M ${offsetX} ${offsetY} L ${offsetX + w} ${offsetY} L ${offsetX + w} ${offsetY + h} L ${offsetX} ${offsetY + h} Z`;

        return {
            pieces,
            borderPath,
            bounds: { x: offsetX, y: offsetY, w, h },
            grid: { cols, rows },
            canvasW: this.canvas.width,
            canvasH: this.canvas.height
        };
    }

    createPiecePath(x, y, w, h, tabSize, top, right, bottom, left) {
        if (this.state.type === 'square') {
            return `M ${x} ${y} L ${x + w} ${y} L ${x + w} ${y + h} L ${x} ${y + h} Z`;
        }

        let d = `M ${x} ${y}`;

        // Top edge
        d += this.createEdge(x, y, x + w, y, tabSize, top, 'h');
        // Right edge
        d += this.createEdge(x + w, y, x + w, y + h, tabSize, right, 'v');
        // Bottom edge
        d += this.createEdge(x + w, y + h, x, y + h, tabSize, bottom, 'h');
        // Left edge
        d += this.createEdge(x, y + h, x, y, tabSize, left, 'v');

        d += ' Z';
        return d;
    }

    createEdge(x1, y1, x2, y2, tabSize, dir, orientation) {
        if (dir === 0) return ` L ${x2} ${y2}`;

        const isH = orientation === 'h';
        const len = isH ? Math.abs(x2 - x1) : Math.abs(y2 - y1);
        const sign = isH ? (x2 > x1 ? 1 : -1) : (y2 > y1 ? 1 : -1);

        const neckW = tabSize * 0.45;
        const headR = tabSize * 0.6;
        const neckL = tabSize * 0.3;
        const depth = tabSize * dir;

        let d = '';

        if (isH) {
            const midX = (x1 + x2) / 2;
            const neckStart = midX - neckW * sign;
            const neckEnd = midX + neckW * sign;

            d += ` L ${neckStart} ${y1}`;
            d += ` L ${neckStart} ${y1 + neckL * Math.sign(depth)}`;

            // Head curve
            d += ` C ${neckStart - headR * 0.2 * sign} ${y1 + depth * 0.6},`;
            d += ` ${midX - headR * sign} ${y1 + depth},`;
            d += ` ${midX} ${y1 + depth + headR * 0.1 * Math.sign(depth)}`;

            d += ` C ${midX + headR * sign} ${y1 + depth},`;
            d += ` ${neckEnd + headR * 0.2 * sign} ${y1 + depth * 0.6},`;
            d += ` ${neckEnd} ${y1 + neckL * Math.sign(depth)}`;

            d += ` L ${neckEnd} ${y1}`;
            d += ` L ${x2} ${y2}`;
        } else {
            const midY = (y1 + y2) / 2;
            const neckStart = midY - neckW * sign;
            const neckEnd = midY + neckW * sign;

            d += ` L ${x1} ${neckStart}`;
            d += ` L ${x1 + neckL * Math.sign(depth)} ${neckStart}`;

            // Head curve
            d += ` C ${x1 + depth * 0.6} ${neckStart - headR * 0.2 * sign},`;
            d += ` ${x1 + depth} ${midY - headR * sign},`;
            d += ` ${x1 + depth + headR * 0.1 * Math.sign(depth)} ${midY}`;

            d += ` C ${x1 + depth} ${midY + headR * sign},`;
            d += ` ${x1 + depth * 0.6} ${neckEnd + headR * 0.2 * sign},`;
            d += ` ${x1 + neckL * Math.sign(depth)} ${neckEnd}`;

            d += ` L ${x1} ${neckEnd}`;
            d += ` L ${x2} ${y2}`;
        }

        return d;
    }

    render() {
        const ctx = this.ctx;
        const data = this.puzzleData;

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw image clipped to border
        ctx.save();
        const borderClip = new Path2D(data.borderPath);
        ctx.clip(borderClip);
        ctx.drawImage(this.image, data.bounds.x, data.bounds.y, data.bounds.w, data.bounds.h);
        ctx.restore();

        // Draw puzzle lines
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = this.state.strokeWidth;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        data.pieces.forEach(piece => {
            const path = new Path2D(piece.path);
            ctx.stroke(path);
        });

        // Border
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = this.state.strokeWidth * 1.5;
        ctx.stroke(borderClip);
    }

    enableButtons() {
        document.getElementById('btnSavePNG').disabled = false;
        document.getElementById('btnSaveSVG').disabled = false;
        document.getElementById('btnSaveDXF').disabled = false;
        document.getElementById('btnSaveCutLines').disabled = false;
    }

    exportPNG(withImage = true) {
        if (!this.puzzleData) return;

        const canvas = document.createElement('canvas');
        canvas.width = this.canvas.width * 2;
        canvas.height = this.canvas.height * 2;
        const ctx = canvas.getContext('2d');
        ctx.scale(2, 2);

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (withImage) {
            ctx.save();
            const clip = new Path2D(this.puzzleData.borderPath);
            ctx.clip(clip);
            ctx.drawImage(this.image, this.puzzleData.bounds.x, this.puzzleData.bounds.y,
                         this.puzzleData.bounds.w, this.puzzleData.bounds.h);
            ctx.restore();
        }

        ctx.strokeStyle = '#000000';
        ctx.lineWidth = this.state.strokeWidth;
        ctx.lineJoin = 'round';

        this.puzzleData.pieces.forEach(piece => {
            ctx.stroke(new Path2D(piece.path));
        });

        ctx.lineWidth = this.state.strokeWidth * 1.5;
        ctx.stroke(new Path2D(this.puzzleData.borderPath));

        canvas.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `puzzle-${withImage ? 'print' : 'cutlines'}-${Date.now()}.png`;
            a.click();
            URL.revokeObjectURL(url);
            this.toast(withImage ? 'PNG –¥–ª—è –ø–µ—á–∞—Ç–∏ —Å–∫–∞—á–∞–Ω!' : '–ö–æ–Ω—Ç—É—Ä—ã —Å–∫–∞—á–∞–Ω—ã!');
        }, 'image/png');
    }

    exportSVG() {
        if (!this.puzzleData) return;

        const data = this.puzzleData;
        let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${data.canvasW}" height="${data.canvasH}" viewBox="0 0 ${data.canvasW} ${data.canvasH}"
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <clipPath id="borderClip">
            <path d="${data.borderPath}"/>
        </clipPath>
    </defs>
    <rect width="100%" height="100%" fill="white"/>
    <image xlink:href="${this.image.src}" x="${data.bounds.x}" y="${data.bounds.y}"
           width="${data.bounds.w}" height="${data.bounds.h}" clip-path="url(#borderClip)"/>
    <g fill="none" stroke="#333" stroke-width="${this.state.strokeWidth}" stroke-linejoin="round">
`;
        data.pieces.forEach(p => { svg += `        <path d="${p.path}"/>\n`; });
        svg += `    </g>
    <path d="${data.borderPath}" fill="none" stroke="#000" stroke-width="${this.state.strokeWidth * 1.5}"/>
</svg>`;

        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `puzzle-${Date.now()}.svg`;
        a.click();
        URL.revokeObjectURL(url);
        this.toast('SVG —Å–∫–∞—á–∞–Ω!');
    }

    exportDXF() {
        if (!this.puzzleData) return;

        const data = this.puzzleData;
        const scale = 25.4 / CONFIG.DPI; // px to mm
        const hMM = data.canvasH * scale;

        let dxf = `0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1015\n9\n$INSUNITS\n70\n4\n0\nENDSEC\n`;
        dxf += `0\nSECTION\n2\nTABLES\n0\nTABLE\n2\nLTYPE\n70\n1\n0\nLTYPE\n2\nCONTINUOUS\n70\n0\n3\nSolid\n72\n65\n73\n0\n40\n0\n0\nENDTAB\n`;
        dxf += `0\nTABLE\n2\nLAYER\n70\n1\n0\nLAYER\n2\nCUT\n70\n0\n62\n1\n6\nCONTINUOUS\n0\nENDTAB\n0\nENDSEC\n`;
        dxf += `0\nSECTION\n2\nENTITIES\n`;

        const pathToDXF = (pathStr) => {
            const points = this.pathToPoints(pathStr);
            if (points.length < 2) return '';

            let out = `0\nLWPOLYLINE\n8\nCUT\n90\n${points.length}\n70\n1\n`;
            points.forEach(p => {
                out += `10\n${(p.x * scale).toFixed(4)}\n20\n${(hMM - p.y * scale).toFixed(4)}\n`;
            });
            return out;
        };

        data.pieces.forEach(p => { dxf += pathToDXF(p.path); });
        dxf += pathToDXF(data.borderPath);
        dxf += `0\nENDSEC\n0\nEOF\n`;

        const blob = new Blob([dxf], { type: 'application/dxf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `puzzle-${Date.now()}.dxf`;
        a.click();
        URL.revokeObjectURL(url);
        this.toast('DXF –¥–ª—è –ß–ü–£ —Å–∫–∞—á–∞–Ω!');
    }

    pathToPoints(pathStr) {
        const points = [];
        const cmds = pathStr.match(/[MLCZ][^MLCZ]*/gi) || [];
        let cx = 0, cy = 0;

        cmds.forEach(cmd => {
            const type = cmd[0].toUpperCase();
            const vals = cmd.slice(1).trim().split(/[\s,]+/).filter(v => v).map(parseFloat);

            if (type === 'M' || type === 'L') {
                cx = vals[0]; cy = vals[1];
                points.push({ x: cx, y: cy });
            } else if (type === 'C') {
                // Bezier approximation
                const cp1x = vals[0], cp1y = vals[1];
                const cp2x = vals[2], cp2y = vals[3];
                const ex = vals[4], ey = vals[5];

                for (let t = 0.1; t <= 1; t += 0.1) {
                    const t2 = t * t, t3 = t2 * t;
                    const mt = 1 - t, mt2 = mt * mt, mt3 = mt2 * mt;
                    points.push({
                        x: mt3 * cx + 3 * mt2 * t * cp1x + 3 * mt * t2 * cp2x + t3 * ex,
                        y: mt3 * cy + 3 * mt2 * t * cp1y + 3 * mt * t2 * cp2y + t3 * ey
                    });
                }
                cx = ex; cy = ey;
            }
        });

        return points;
    }

    toast(msg) {
        const el = document.getElementById('toast');
        el.textContent = msg;
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 2500);
    }
}

// Init
document.addEventListener('DOMContentLoaded', () => {
    window.app = new PuzzleGenerator();
});
</script>
</body>
</html>
