<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Puzzle Generator Pro - Circular Fix</title>
<style>
    :root {
        --primary: #2563eb;
        --primary-dark: #1e40af;
        --surface: #ffffff;
        --bg-app: #f1f5f9;
        --border: #cbd5e1;
        --text-main: #0f172a;
        --text-sec: #64748b;
        --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }

    body {
        background: var(--bg-app);
        color: var(--text-main);
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    header {
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        padding: 0.75rem 1.5rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
        z-index: 20;
    }

    .brand {
        font-weight: 800;
        font-size: 1.25rem;
        color: var(--primary-dark);
        display: flex;
        align-items: center;
        gap: 10px;
    }

    main {
        display: grid;
        grid-template-columns: 340px 1fr;
        height: 100%;
        overflow: hidden;
    }

    aside {
        background: var(--surface);
        border-right: 1px solid var(--border);
        padding: 1.5rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
    }

    .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
    .label { font-size: 0.75rem; font-weight: 700; color: var(--text-sec); text-transform: uppercase; letter-spacing: 0.08em; }

    .upload-box {
        border: 2px dashed var(--border);
        border-radius: 10px;
        padding: 1.5rem;
        text-align: center;
        cursor: pointer;
        transition: 0.2s;
        background: var(--bg-app);
        position: relative;
        overflow: hidden;
    }
    .upload-box:hover { border-color: var(--primary); background: #eff6ff; }
    .upload-box input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
    .preview-img { max-width: 100%; max-height: 140px; display: none; margin: 0 auto; border-radius: 6px; box-shadow: var(--shadow); }

    .puzzle-types { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    .type-card { position: relative; }
    .type-card input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
    .type-content {
        border: 2px solid var(--border);
        border-radius: 10px;
        padding: 1rem 0.5rem;
        text-align: center;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-sec);
        cursor: pointer;
        transition: 0.2s;
    }
    .type-content .icon { font-size: 1.5rem; display: block; margin-bottom: 4px; }
    .type-card input:checked + .type-content { border-color: var(--primary); background: #eff6ff; color: var(--primary); }

    input[type="range"] { width: 100%; accent-color: var(--primary); margin: 8px 0; }
    input[type="number"] {
        width: 100%;
        padding: 0.6rem;
        border: 1px solid var(--border);
        border-radius: 8px;
        font-size: 0.9rem;
    }

    .btn {
        background: var(--primary);
        color: white;
        border: none;
        padding: 0.9rem;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        display: flex; align-items: center; justify-content: center; gap: 8px;
        transition: 0.2s;
        font-size: 0.95rem;
    }
    .btn:hover { background: var(--primary-dark); transform: translateY(-1px); box-shadow: var(--shadow); }
    .btn-secondary { background: #64748b; }
    .btn-secondary:hover { background: #475569; }

    .workspace {
        background: #e2e8f0;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: auto;
        padding: 2rem;
        background-image:
            linear-gradient(45deg, #cbd5e1 25%, transparent 25%),
            linear-gradient(-45deg, #cbd5e1 25%, transparent 25%),
            linear-gradient(45deg, transparent 75%, #cbd5e1 75%),
            linear-gradient(-45deg, transparent 75%, #cbd5e1 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    canvas {
        background: white;
        box-shadow: 0 10px 40px -5px rgba(0,0,0,0.2);
        max-width: 100%;
        max-height: 100%;
    }

    .actions {
        position: absolute; bottom: 1.5rem; right: 1.5rem;
        background: var(--surface);
        padding: 0.6rem;
        border-radius: 14px;
        display: flex; gap: 0.5rem;
        box-shadow: 0 10px 40px -5px rgba(0,0,0,0.2);
    }

    .icon-btn {
        width: 52px; height: 52px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: var(--surface);
        cursor: pointer;
        display: flex; align-items: center; justify-content: center;
        color: var(--text-sec);
        transition: 0.2s;
        position: relative;
    }
    .icon-btn:hover:not(:disabled) { color: var(--primary); border-color: var(--primary); background: #eff6ff; transform: scale(1.05); }
    .icon-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .icon-btn::after {
        content: attr(data-tooltip);
        position: absolute; bottom: 115%; left: 50%; transform: translateX(-50%);
        background: #1e293b; color: white; padding: 6px 12px;
        border-radius: 6px; font-size: 0.7rem; white-space: nowrap;
        opacity: 0; pointer-events: none; transition: 0.2s;
    }
    .icon-btn:hover::after { opacity: 1; }

    .toast {
        position: fixed; top: 24px; left: 50%; transform: translateX(-50%) translateY(-100px);
        background: #1e293b; color: white; padding: 0.85rem 1.75rem;
        border-radius: 50px; box-shadow: 0 10px 25px -3px rgba(0,0,0,0.2);
        font-weight: 500; z-index: 100; font-size: 0.9rem;
        transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .toast.show { transform: translateX(-50%) translateY(0); }

    .paper-selector { display: flex; gap: 8px; }
    .paper-btn {
        flex: 1;
        padding: 10px;
        border: 2px solid var(--border);
        border-radius: 10px;
        background: white;
        cursor: pointer;
        text-align: center;
        font-weight: 600;
        font-size: 0.85rem;
        transition: 0.2s;
    }
    .paper-btn.active { border-color: var(--primary); background: #eff6ff; color: var(--primary); }
    .paper-btn span { display: block; font-size: 0.7rem; color: #94a3b8; margin-top: 2px; }
    .paper-btn.active span { color: var(--primary); }

    @media (max-width: 1000px) {
        main { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
        aside { max-height: 35vh; border-bottom: 1px solid var(--border); padding: 1rem; }
        .actions { bottom: 1rem; right: 1rem; flex-wrap: wrap; width: calc(100% - 2rem); justify-content: center; }
    }
</style>
</head>
<body>

<header>
    <div class="brand">
        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M19.439 15.424a2.252 2.252 0 0 1-1.914-1.034l-1.864-2.968a2.252 2.252 0 0 0-1.914-1.034h-1.874a2.252 2.252 0 0 0-1.914 1.034l-1.864 2.968a2.252 2.252 0 0 1-1.914 1.034h-.005"/>
            <path d="M12 3v3"/><path d="M3 12h3"/><path d="M12 21v-3"/><path d="M21 12h-3"/>
        </svg>
        Puzzle Generator Pro
    </div>
    <div style="font-size: 0.8rem; color: var(--text-sec);">
        Circular Puzzle Fixed
    </div>
</header>

<main>
    <aside>
        <div class="control-group">
            <div class="label">1. Загрузить изображение</div>
            <div class="upload-box" id="dropZone">
                <input type="file" id="fileInput" accept="image/*">
                <div id="uploadPlaceholder">
                    <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <div style="margin-top:10px; font-size:0.85rem; color:#64748b;">Нажмите или перетащите фото</div>
                </div>
                <img id="imagePreview" class="preview-img" alt="">
            </div>
        </div>

        <div class="control-group">
            <div class="label">2. Формат бумаги</div>
            <div class="paper-selector">
                <div class="paper-btn active" data-paper="a4">
                    A4
                    <span>297x210 мм</span>
                </div>
                <div class="paper-btn" data-paper="a3">
                    A3
                    <span>420x297 мм</span>
                </div>
            </div>
        </div>

        <div class="control-group">
            <div class="label">3. Тип пазла</div>
            <div class="puzzle-types">
                <div class="type-card">
                    <input type="radio" name="puzzleType" value="classic" checked>
                    <div class="type-content">
                        <span class="icon">&#129513;</span>
                        Классический
                    </div>
                </div>
                <div class="type-card">
                    <input type="radio" name="puzzleType" value="square">
                    <div class="type-content">
                        <span class="icon">&#11036;</span>
                        Квадраты
                    </div>
                </div>
                <div class="type-card">
                    <input type="radio" name="puzzleType" value="circular">
                    <div class="type-content">
                        <span class="icon">&#11093;</span>
                        Круглый
                    </div>
                </div>
            </div>
        </div>

        <div class="control-group">
            <div class="label">4. Количество деталей</div>
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="font-size:0.75rem; color:#64748b; min-width:38px;">Легко</span>
                <input type="range" id="difficulty" min="1" max="10" value="4" style="flex:1;">
                <span id="piecesCount" style="font-weight:700; color:var(--primary); min-width:55px; font-size:0.9rem;">48 шт</span>
                <span style="font-size:0.75rem; color:#64748b; min-width:38px;">Сложно</span>
            </div>
        </div>

        <div class="control-group">
            <div class="label">5. Параметры реза</div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <div>
                    <label style="font-size:0.7rem; color:#64748b; display:block; margin-bottom:4px;">Отступ от края (мм)</label>
                    <input type="number" id="bleed" value="5" min="0" max="20">
                </div>
                <div>
                    <label style="font-size:0.7rem; color:#64748b; display:block; margin-bottom:4px;">Толщина линии (мм)</label>
                    <input type="number" id="strokeWidth" value="0.5" step="0.1" min="0.1" max="3">
                </div>
            </div>
        </div>

        <div class="control-group">
            <div class="label">6. Настройки</div>
            <div style="display:flex; flex-direction:column; gap:10px;">
                <label style="font-size:0.85rem; display:flex; align-items:center; gap:8px; cursor:pointer;">
                    <input type="checkbox" id="showBorders" checked style="width:18px; height:18px;">
                    Показывать границы деталей
                </label>
                <label style="font-size:0.85rem; display:flex; align-items:center; gap:8px; cursor:pointer;">
                    <input type="checkbox" id="numbered" style="width:18px; height:18px;">
                    Нумеровать детали
                </label>
            </div>
        </div>

        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:auto;">
            <button class="btn" id="btnGenerate">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                </svg>
                Сгенерировать
            </button>
            <button class="btn btn-secondary" id="btnClear">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/>
                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>
                </svg>
                Очистить
            </button>
        </div>
    </aside>

    <div class="workspace">
        <canvas id="canvas"></canvas>
    </div>
</main>

<div class="actions">
    <button class="icon-btn" id="btnPrint" disabled data-tooltip="PNG с изображением">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M6 9V2h12v7"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/>
            <path d="M6 14h12v8H6z"/>
        </svg>
    </button>
    <button class="icon-btn" id="btnCut" disabled data-tooltip="PNG линии реза">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
        </svg>
    </button>
    <button class="icon-btn" id="btnSVG" disabled data-tooltip="Векторный SVG">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
            <polyline points="21 15 16 10 5 21"/>
        </svg>
    </button>
    <button class="icon-btn" id="btnDXF" disabled data-tooltip="DXF для ЧПУ">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="M9 15h6"/>
        </svg>
    </button>
</div>

<div id="toast" class="toast">Сообщение</div>

<script>
/**
 * PUZZLE GENERATOR PRO - CIRCULAR PUZZLE FIX
 *
 * Ключевые исправления:
 * 1. Упрощённая полярная сетка - одинаковое кол-во секторов во всех кольцах
 * 2. Рёбра генерируются ОДИН РАЗ и переиспользуются
 * 3. Правильное построение путей для круговых деталей
 */

const CONFIG = {
    DPI: 96,
    MM_TO_PX: 96 / 25.4,
    PAPER: {
        a4: { w: 297, h: 210 },
        a3: { w: 420, h: 297 }
    },
    PIECES_MAP: [12, 24, 36, 48, 72, 96, 120, 150, 200, 300]
};

class SeededRandom {
    constructor(seed = Date.now()) {
        this.seed = seed;
    }

    next() {
        this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
        return this.seed / 0x7fffffff;
    }

    nextFloat(min, max) {
        return min + this.next() * (max - min);
    }
}

class PuzzleGenerator {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.rng = new SeededRandom();

        this.state = {
            image: null,
            paper: 'a4',
            type: 'classic',
            difficulty: 4,
            bleed: 5,
            strokeWidth: 0.5,
            showBorders: true,
            numbered: false
        };

        this.pieces = [];
        this.edges = { h: [], v: [], radial: [], arc: [] };
        this.imgBounds = { x: 0, y: 0, w: 0, h: 0 };
        this.grid = { rows: 0, cols: 0 };
        this.circleBounds = null;

        this.initCanvas();
        this.initListeners();
    }

    initCanvas() {
        const paperSize = CONFIG.PAPER[this.state.paper];
        const pxPerMm = CONFIG.MM_TO_PX;
        this.canvas.width = paperSize.w * pxPerMm;
        this.canvas.height = paperSize.h * pxPerMm;
        this.renderPlaceholder();
    }

    initListeners() {
        const fileInput = document.getElementById('fileInput');
        fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));

        const dz = document.getElementById('dropZone');
        dz.addEventListener('dragover', (e) => {
            e.preventDefault();
            dz.style.borderColor = 'var(--primary)';
            dz.style.background = '#eff6ff';
        });
        dz.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dz.style.borderColor = '';
            dz.style.background = '';
        });
        dz.addEventListener('drop', (e) => {
            e.preventDefault();
            dz.style.borderColor = '';
            dz.style.background = '';
            if(e.dataTransfer.files[0]) this.handleFile(e.dataTransfer.files[0]);
        });

        document.querySelectorAll('.paper-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.paper-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.state.paper = btn.dataset.paper;
                if(this.state.image) this.generate();
            });
        });

        document.querySelectorAll('input[name="puzzleType"]').forEach(el =>
            el.addEventListener('change', (e) => {
                this.state.type = e.target.value;
                if(this.state.image) this.generate();
            })
        );

        const diffSlider = document.getElementById('difficulty');
        diffSlider.addEventListener('input', (e) => {
            this.state.difficulty = parseInt(e.target.value);
            document.getElementById('piecesCount').textContent = `${CONFIG.PIECES_MAP[this.state.difficulty-1]} шт`;
        });
        diffSlider.addEventListener('change', () => {
            if(this.state.image) this.generate();
        });

        document.getElementById('bleed').addEventListener('change', (e) => {
            this.state.bleed = parseFloat(e.target.value);
            if(this.state.image) this.generate();
        });
        document.getElementById('strokeWidth').addEventListener('change', (e) => {
            this.state.strokeWidth = parseFloat(e.target.value);
            this.render();
        });
        document.getElementById('showBorders').addEventListener('change', (e) => {
            this.state.showBorders = e.target.checked;
            this.render();
        });
        document.getElementById('numbered').addEventListener('change', (e) => {
            this.state.numbered = e.target.checked;
            this.render();
        });

        document.getElementById('btnGenerate').addEventListener('click', () => this.generate());
        document.getElementById('btnClear').addEventListener('click', () => this.clear());
        document.getElementById('btnPrint').addEventListener('click', () => this.downloadPNG('print'));
        document.getElementById('btnCut').addEventListener('click', () => this.downloadPNG('cut'));
        document.getElementById('btnSVG').addEventListener('click', () => this.downloadSVG());
        document.getElementById('btnDXF').addEventListener('click', () => this.downloadDXF());
    }

    handleFile(file) {
        if(!file || !file.type.startsWith('image/')) {
            this.showToast('Выберите изображение');
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.state.image = img;
                document.getElementById('imagePreview').src = img.src;
                document.getElementById('imagePreview').style.display = 'block';
                document.getElementById('uploadPlaceholder').style.display = 'none';
                this.showToast('Изображение загружено!');
                setTimeout(() => this.generate(), 100);
            };
            img.onerror = () => this.showToast('Ошибка загрузки');
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    clear() {
        this.state.image = null;
        this.pieces = [];
        this.edges = { h: [], v: [], radial: [], arc: [] };
        this.circleBounds = null;
        document.getElementById('imagePreview').style.display = 'none';
        document.getElementById('imagePreview').src = '';
        document.getElementById('uploadPlaceholder').style.display = 'block';
        this.initCanvas();
        document.querySelectorAll('.icon-btn').forEach(b => b.disabled = true);
        this.showToast('Очищено');
    }

    generate() {
        if(!this.state.image) return;

        this.rng = new SeededRandom(Date.now());

        const paperSize = CONFIG.PAPER[this.state.paper];
        const pxPerMm = CONFIG.MM_TO_PX;
        this.canvas.width = paperSize.w * pxPerMm;
        this.canvas.height = paperSize.h * pxPerMm;

        this.calculateImageBounds();

        if (this.state.type === 'circular') {
            this.generateCircularPuzzle();
        } else {
            this.generateRectangularPuzzle();
        }

        this.render();
        document.querySelectorAll('.icon-btn').forEach(b => b.disabled = false);
        this.showToast(`Сгенерировано ${this.pieces.length} деталей`);
    }

    calculateImageBounds() {
        const bleedPx = this.state.bleed * CONFIG.MM_TO_PX;
        const availW = this.canvas.width - (bleedPx * 2);
        const availH = this.canvas.height - (bleedPx * 2);
        const imgAspect = this.state.image.width / this.state.image.height;

        if (this.state.type === 'circular') {
            const minDim = Math.min(availW, availH);
            this.circleBounds = {
                cx: this.canvas.width / 2,
                cy: this.canvas.height / 2,
                radius: minDim / 2 - 5
            };
            // Image bounds for circular - square containing the circle
            this.imgBounds.w = this.circleBounds.radius * 2;
            this.imgBounds.h = this.circleBounds.radius * 2;
            this.imgBounds.x = this.circleBounds.cx - this.circleBounds.radius;
            this.imgBounds.y = this.circleBounds.cy - this.circleBounds.radius;
        } else {
            this.circleBounds = null;
            const areaAspect = availW / availH;
            if (imgAspect > areaAspect) {
                this.imgBounds.w = availW;
                this.imgBounds.h = availW / imgAspect;
            } else {
                this.imgBounds.h = availH;
                this.imgBounds.w = availH * imgAspect;
            }
            this.imgBounds.x = (this.canvas.width - this.imgBounds.w) / 2;
            this.imgBounds.y = (this.canvas.height - this.imgBounds.h) / 2;
        }
    }

    // ========== CIRCULAR PUZZLE ==========

    generateCircularPuzzle() {
        const targetPieces = CONFIG.PIECES_MAP[this.state.difficulty - 1];
        const { cx, cy, radius } = this.circleBounds;

        // Calculate rings and sectors
        // For simplicity: all rings have the same number of sectors
        // numRings * numSectors = targetPieces (approximately)

        let numRings = Math.max(2, Math.round(Math.sqrt(targetPieces / 6)));
        let numSectors = Math.round(targetPieces / numRings);

        // Ensure minimum values
        if (numRings < 2) numRings = 2;
        if (numSectors < 4) numSectors = 4;
        if (numRings > 8) numRings = 8;
        if (numSectors > 24) numSectors = 24;

        this.grid = { rings: numRings, sectors: numSectors };

        // Generate polar mesh points
        // mesh[ring][sector] = point at that intersection
        const mesh = [];
        for (let r = 0; r <= numRings; r++) {
            mesh[r] = [];
            const ringRadius = (r / numRings) * radius;
            for (let s = 0; s <= numSectors; s++) {
                const angle = (s / numSectors) * Math.PI * 2 - Math.PI / 2;
                mesh[r][s] = {
                    x: cx + Math.cos(angle) * ringRadius,
                    y: cy + Math.sin(angle) * ringRadius,
                    angle: angle,
                    radius: ringRadius
                };
            }
        }
        this.polarMesh = mesh;

        // Generate edges
        this.edges = { radial: [], arc: [] };

        // Radial edges: from ring r to ring r+1 at each sector boundary
        // radial[r][s] = edge from mesh[r][s] to mesh[r+1][s]
        for (let r = 0; r < numRings; r++) {
            this.edges.radial[r] = [];
            for (let s = 0; s <= numSectors; s++) {
                const p1 = mesh[r][s];
                const p2 = mesh[r + 1][s];

                // Inner boundary (r=0) and sector boundaries at s=0 and s=numSectors are straight
                // But s=0 and s=numSectors are the same sector (wrap around), so we only draw once
                const isBorder = (s === 0 || s === numSectors); // These edges overlap, draw only one

                if (s < numSectors) { // Don't duplicate the last edge
                    const tab = (r === 0) ? null : this.generateTabParams(); // No tabs from center
                    this.edges.radial[r][s] = {
                        points: this.generateRadialEdgePoints(p1, p2, tab),
                        tab: tab
                    };
                }
            }
        }

        // Arc edges: along each ring between sectors
        // arc[r][s] = edge along ring r from sector s to sector s+1
        for (let r = 1; r <= numRings; r++) {
            this.edges.arc[r] = [];
            for (let s = 0; s < numSectors; s++) {
                const p1 = mesh[r][s];
                const p2 = mesh[r][s + 1];

                // Outer boundary (r = numRings) has no tabs
                const isOuter = (r === numRings);
                const tab = isOuter ? null : this.generateTabParams();

                this.edges.arc[r][s] = {
                    points: this.generateArcEdgePoints(p1, p2, r, numRings, tab),
                    tab: tab,
                    isOuter: isOuter
                };
            }
        }

        // Create piece paths
        this.pieces = [];
        for (let r = 0; r < numRings; r++) {
            for (let s = 0; s < numSectors; s++) {
                const piece = this.buildCircularPiecePath(r, s, numRings, numSectors, mesh);
                this.pieces.push(piece);
            }
        }
    }

    generateTabParams() {
        if (this.state.type === 'square') return null;
        return {
            dir: this.rng.next() > 0.5 ? 1 : -1,
            neckWidth: this.rng.nextFloat(0.08, 0.12),
            headWidth: this.rng.nextFloat(0.14, 0.18),
            height: this.rng.nextFloat(0.16, 0.22)
        };
    }

    generateRadialEdgePoints(p1, p2, tab) {
        if (!tab) {
            return [{ x: p1.x, y: p1.y }, { x: p2.x, y: p2.y }];
        }

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy);

        if (len < 20) {
            return [{ x: p1.x, y: p1.y }, { x: p2.x, y: p2.y }];
        }

        return this.generateTabPoints(p1, p2, tab);
    }

    generateArcEdgePoints(p1, p2, ring, totalRings, tab) {
        if (!tab) {
            return [{ x: p1.x, y: p1.y }, { x: p2.x, y: p2.y }];
        }

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy);

        if (len < 20) {
            return [{ x: p1.x, y: p1.y }, { x: p2.x, y: p2.y }];
        }

        return this.generateTabPoints(p1, p2, tab);
    }

    generateTabPoints(p1, p2, tab) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy);

        const tx = dx / len;
        const ty = dy / len;
        const nx = -ty;
        const ny = tx;

        const dir = tab.dir;
        const neckW = tab.neckWidth;
        const headW = tab.headWidth;
        const tabH = tab.height;

        const P = (t, h) => {
            const hScaled = h * dir * len;
            return {
                x: p1.x + t * len * tx + hScaled * nx,
                y: p1.y + t * len * ty + hScaled * ny
            };
        };

        const points = [];
        const nL = 0.5 - neckW;
        const nR = 0.5 + neckW;
        const hL = 0.5 - headW;
        const hR = 0.5 + headW;

        points.push(P(0, 0));
        points.push(P(nL, 0));

        // Left side curve up
        const steps = 8;
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            points.push(this.cubicBezier(
                P(nL, 0),
                P(nL, tabH * 0.4),
                P(hL, tabH * 0.6),
                P(hL, tabH),
                t
            ));
        }

        // Top curve
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            points.push(this.cubicBezier(
                P(hL, tabH),
                P(hL, tabH + 0.05),
                P(hR, tabH + 0.05),
                P(hR, tabH),
                t
            ));
        }

        // Right side curve down
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            points.push(this.cubicBezier(
                P(hR, tabH),
                P(hR, tabH * 0.6),
                P(nR, tabH * 0.4),
                P(nR, 0),
                t
            ));
        }

        points.push(P(1, 0));

        return points;
    }

    cubicBezier(p0, p1, p2, p3, t) {
        const it = 1 - t;
        return {
            x: it*it*it*p0.x + 3*it*it*t*p1.x + 3*it*t*t*p2.x + t*t*t*p3.x,
            y: it*it*it*p0.y + 3*it*it*t*p1.y + 3*it*t*t*p2.y + t*t*t*p3.y
        };
    }

    buildCircularPiecePath(ring, sector, numRings, numSectors, mesh) {
        const fmt = (p) => `${p.x.toFixed(2)} ${p.y.toFixed(2)}`;

        // Get corner points
        const innerLeft = mesh[ring][sector];
        const innerRight = mesh[ring][sector + 1];
        const outerRight = mesh[ring + 1][sector + 1];
        const outerLeft = mesh[ring + 1][sector];

        // Get edges
        const innerArc = (ring === 0) ? null : this.edges.arc[ring][sector];
        const outerArc = this.edges.arc[ring + 1][sector];
        const leftRadial = this.edges.radial[ring][sector];
        const rightRadial = this.edges.radial[ring][sector + 1] || this.edges.radial[ring][0]; // wrap

        let d = '';

        if (ring === 0) {
            // Center piece - starts from center point
            const { cx, cy } = this.circleBounds;
            d = `M ${cx.toFixed(2)} ${cy.toFixed(2)}`;

            // Radial edge to outer (left side)
            if (leftRadial && leftRadial.points.length > 1) {
                for (let i = 1; i < leftRadial.points.length; i++) {
                    d += ` L ${fmt(leftRadial.points[i])}`;
                }
            } else {
                d += ` L ${fmt(outerLeft)}`;
            }

            // Arc along outer ring
            if (outerArc && outerArc.points.length > 1) {
                for (let i = 1; i < outerArc.points.length; i++) {
                    d += ` L ${fmt(outerArc.points[i])}`;
                }
            } else {
                d += ` L ${fmt(outerRight)}`;
            }

            // Radial edge back to center (right side, reversed)
            if (rightRadial && rightRadial.points.length > 1) {
                for (let i = rightRadial.points.length - 2; i >= 0; i--) {
                    d += ` L ${fmt(rightRadial.points[i])}`;
                }
            } else {
                d += ` L ${cx.toFixed(2)} ${cy.toFixed(2)}`;
            }
        } else {
            // Regular ring piece
            d = `M ${fmt(innerLeft)}`;

            // Inner arc (reversed direction since we go counterclockwise on inner)
            if (innerArc && innerArc.points.length > 1) {
                for (let i = 1; i < innerArc.points.length; i++) {
                    d += ` L ${fmt(innerArc.points[i])}`;
                }
            } else {
                d += ` L ${fmt(innerRight)}`;
            }

            // Right radial edge (going outward)
            if (rightRadial && rightRadial.points.length > 1) {
                for (let i = 1; i < rightRadial.points.length; i++) {
                    d += ` L ${fmt(rightRadial.points[i])}`;
                }
            } else {
                d += ` L ${fmt(outerRight)}`;
            }

            // Outer arc (reversed)
            if (outerArc && outerArc.points.length > 1) {
                for (let i = outerArc.points.length - 2; i >= 0; i--) {
                    d += ` L ${fmt(outerArc.points[i])}`;
                }
            } else {
                d += ` L ${fmt(outerLeft)}`;
            }

            // Left radial edge (going inward, reversed)
            if (leftRadial && leftRadial.points.length > 1) {
                for (let i = leftRadial.points.length - 2; i >= 0; i--) {
                    d += ` L ${fmt(leftRadial.points[i])}`;
                }
            } else {
                d += ` L ${fmt(innerLeft)}`;
            }
        }

        d += ' Z';

        // Calculate center for numbering
        const midAngle = ((sector + 0.5) / numSectors) * Math.PI * 2 - Math.PI / 2;
        const midRadius = ((ring + 0.5) / numRings) * this.circleBounds.radius;
        const center = {
            x: this.circleBounds.cx + Math.cos(midAngle) * midRadius,
            y: this.circleBounds.cy + Math.sin(midAngle) * midRadius
        };

        return { path: d, center, ring, sector };
    }

    // ========== RECTANGULAR PUZZLE ==========

    generateRectangularPuzzle() {
        const targetPieces = CONFIG.PIECES_MAP[this.state.difficulty - 1];
        const { x, y, w, h } = this.imgBounds;
        const aspect = w / h;

        let rows = Math.round(Math.sqrt(targetPieces / aspect));
        let cols = Math.round(targetPieces / rows);

        if (rows < 2) rows = 2;
        if (cols < 2) cols = 2;
        if (rows > 20) rows = 20;
        if (cols > 30) cols = 30;

        this.grid = { rows, cols };

        // Create mesh with jitter
        const pW = w / cols;
        const pH = h / rows;
        const mesh = [];

        for (let r = 0; r <= rows; r++) {
            mesh[r] = [];
            for (let c = 0; c <= cols; c++) {
                let px = x + c * pW;
                let py = y + r * pH;

                // Add jitter to internal points
                if (r > 0 && r < rows && c > 0 && c < cols) {
                    px += this.rng.nextFloat(-pW * 0.12, pW * 0.12);
                    py += this.rng.nextFloat(-pH * 0.12, pH * 0.12);
                }

                mesh[r][c] = { x: px, y: py };
            }
        }
        this.rectMesh = mesh;

        // Generate edges
        this.edges = { h: [], v: [] };

        // Horizontal edges
        for (let r = 0; r <= rows; r++) {
            this.edges.h[r] = [];
            for (let c = 0; c < cols; c++) {
                const p1 = mesh[r][c];
                const p2 = mesh[r][c + 1];
                const isBorder = (r === 0 || r === rows);
                const tab = isBorder ? null : this.generateTabParams();

                this.edges.h[r][c] = {
                    points: this.generateEdgePoints(p1, p2, tab),
                    isBorder
                };
            }
        }

        // Vertical edges
        for (let r = 0; r < rows; r++) {
            this.edges.v[r] = [];
            for (let c = 0; c <= cols; c++) {
                const p1 = mesh[r][c];
                const p2 = mesh[r + 1][c];
                const isBorder = (c === 0 || c === cols);
                const tab = isBorder ? null : this.generateTabParams();

                this.edges.v[r][c] = {
                    points: this.generateEdgePoints(p1, p2, tab),
                    isBorder
                };
            }
        }

        // Create pieces
        this.pieces = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const piece = this.buildRectPiecePath(r, c, rows, cols, mesh);
                this.pieces.push(piece);
            }
        }
    }

    generateEdgePoints(p1, p2, tab) {
        if (!tab) {
            return [{ x: p1.x, y: p1.y }, { x: p2.x, y: p2.y }];
        }
        return this.generateTabPoints(p1, p2, tab);
    }

    buildRectPiecePath(row, col, rows, cols, mesh) {
        const fmt = (p) => `${p.x.toFixed(2)} ${p.y.toFixed(2)}`;

        const topEdge = this.edges.h[row][col];
        const rightEdge = this.edges.v[row][col + 1];
        const bottomEdge = this.edges.h[row + 1][col];
        const leftEdge = this.edges.v[row][col];

        const p1 = mesh[row][col];

        let d = `M ${fmt(p1)}`;

        // Top edge
        if (topEdge.points.length > 1) {
            for (let i = 1; i < topEdge.points.length; i++) {
                d += ` L ${fmt(topEdge.points[i])}`;
            }
        }

        // Right edge
        if (rightEdge.points.length > 1) {
            for (let i = 1; i < rightEdge.points.length; i++) {
                d += ` L ${fmt(rightEdge.points[i])}`;
            }
        }

        // Bottom edge (reversed)
        if (bottomEdge.points.length > 1) {
            for (let i = bottomEdge.points.length - 2; i >= 0; i--) {
                d += ` L ${fmt(bottomEdge.points[i])}`;
            }
        }

        // Left edge (reversed)
        if (leftEdge.points.length > 1) {
            for (let i = leftEdge.points.length - 2; i >= 0; i--) {
                d += ` L ${fmt(leftEdge.points[i])}`;
            }
        }

        d += ' Z';

        const center = {
            x: (mesh[row][col].x + mesh[row + 1][col + 1].x) / 2,
            y: (mesh[row][col].y + mesh[row + 1][col + 1].y) / 2
        };

        return { path: d, center, row, col };
    }

    // ========== RENDERING ==========

    render() {
        const { width, height } = this.canvas;
        this.ctx.clearRect(0, 0, width, height);
        this.ctx.fillStyle = '#fff';
        this.ctx.fillRect(0, 0, width, height);

        if (!this.state.image) {
            this.renderPlaceholder();
            return;
        }

        const isCircular = this.state.type === 'circular';

        // Draw image with clipping
        this.ctx.save();
        this.ctx.beginPath();
        if (isCircular && this.circleBounds) {
            this.ctx.arc(this.circleBounds.cx, this.circleBounds.cy, this.circleBounds.radius, 0, Math.PI * 2);
        } else {
            this.ctx.rect(this.imgBounds.x, this.imgBounds.y, this.imgBounds.w, this.imgBounds.h);
        }
        this.ctx.clip();
        this.ctx.drawImage(this.state.image, this.imgBounds.x, this.imgBounds.y, this.imgBounds.w, this.imgBounds.h);
        this.ctx.restore();

        // Draw puzzle lines
        if (this.state.showBorders) {
            const strokeWidth = this.state.strokeWidth * CONFIG.MM_TO_PX;
            this.ctx.strokeStyle = '#000';
            this.ctx.lineWidth = strokeWidth;
            this.ctx.lineJoin = 'round';
            this.ctx.lineCap = 'round';
            this.ctx.globalAlpha = 0.85;

            // Clip to puzzle area for internal lines
            this.ctx.save();
            this.ctx.beginPath();
            if (isCircular && this.circleBounds) {
                this.ctx.arc(this.circleBounds.cx, this.circleBounds.cy, this.circleBounds.radius - strokeWidth/2, 0, Math.PI * 2);
            } else {
                this.ctx.rect(this.imgBounds.x, this.imgBounds.y, this.imgBounds.w, this.imgBounds.h);
            }
            this.ctx.clip();

            // Draw all piece paths
            this.pieces.forEach(p => {
                const path = new Path2D(p.path);
                this.ctx.stroke(path);
            });

            this.ctx.restore();
            this.ctx.globalAlpha = 1.0;

            // Draw outer border
            this.ctx.lineWidth = strokeWidth * 1.5;
            if (isCircular && this.circleBounds) {
                this.ctx.beginPath();
                this.ctx.arc(this.circleBounds.cx, this.circleBounds.cy, this.circleBounds.radius, 0, Math.PI * 2);
                this.ctx.stroke();
            } else {
                this.ctx.strokeRect(this.imgBounds.x, this.imgBounds.y, this.imgBounds.w, this.imgBounds.h);
            }
        }

        // Draw piece numbers
        if (this.state.numbered && this.pieces.length > 0) {
            this.ctx.fillStyle = 'rgba(255,255,255,0.9)';
            this.ctx.strokeStyle = '#000';
            this.ctx.lineWidth = 1;
            const fontSize = Math.max(8, Math.min(14, 150 / Math.sqrt(this.pieces.length)));
            this.ctx.font = `bold ${fontSize}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            this.pieces.forEach((p, i) => {
                const num = (i + 1).toString();
                const metrics = this.ctx.measureText(num);
                const pad = 2;

                this.ctx.beginPath();
                this.ctx.roundRect(
                    p.center.x - metrics.width/2 - pad,
                    p.center.y - fontSize/2 - pad,
                    metrics.width + pad * 2,
                    fontSize + pad * 2,
                    3
                );
                this.ctx.fill();
                this.ctx.stroke();

                this.ctx.fillStyle = '#000';
                this.ctx.fillText(num, p.center.x, p.center.y);
                this.ctx.fillStyle = 'rgba(255,255,255,0.9)';
            });
        }
    }

    renderPlaceholder() {
        const { width, height } = this.canvas;
        this.ctx.fillStyle = '#fff';
        this.ctx.fillRect(0, 0, width, height);

        this.ctx.fillStyle = '#94a3b8';
        this.ctx.font = '16px -apple-system, sans-serif';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('Загрузите изображение', width / 2, height / 2);
    }

    // ========== EXPORT ==========

    downloadPNG(mode) {
        if (this.pieces.length === 0) {
            this.showToast('Сначала сгенерируйте пазл');
            return;
        }

        const tmpC = document.createElement('canvas');
        tmpC.width = this.canvas.width;
        tmpC.height = this.canvas.height;
        const tCtx = tmpC.getContext('2d');
        const isCircular = this.state.type === 'circular';

        if (mode === 'cut') {
            tCtx.fillStyle = '#fff';
            tCtx.fillRect(0, 0, tmpC.width, tmpC.height);

            const strokeWidth = this.state.strokeWidth * CONFIG.MM_TO_PX;
            tCtx.strokeStyle = '#000';
            tCtx.lineWidth = strokeWidth;
            tCtx.lineJoin = 'round';
            tCtx.lineCap = 'round';

            // Clip and draw internal lines
            tCtx.save();
            tCtx.beginPath();
            if (isCircular && this.circleBounds) {
                tCtx.arc(this.circleBounds.cx, this.circleBounds.cy, this.circleBounds.radius - strokeWidth/2, 0, Math.PI * 2);
            } else {
                tCtx.rect(this.imgBounds.x, this.imgBounds.y, this.imgBounds.w, this.imgBounds.h);
            }
            tCtx.clip();

            this.pieces.forEach(p => {
                tCtx.stroke(new Path2D(p.path));
            });
            tCtx.restore();

            // Outer border
            tCtx.lineWidth = strokeWidth * 1.5;
            if (isCircular && this.circleBounds) {
                tCtx.beginPath();
                tCtx.arc(this.circleBounds.cx, this.circleBounds.cy, this.circleBounds.radius, 0, Math.PI * 2);
                tCtx.stroke();
            } else {
                tCtx.strokeRect(this.imgBounds.x, this.imgBounds.y, this.imgBounds.w, this.imgBounds.h);
            }
        } else {
            tCtx.drawImage(this.canvas, 0, 0);
        }

        const link = document.createElement('a');
        link.download = `puzzle-${mode}-${Date.now()}.png`;
        link.href = tmpC.toDataURL('image/png');
        link.click();
        this.showToast('PNG сохранён!');
    }

    downloadSVG() {
        if (this.pieces.length === 0) {
            this.showToast('Сначала сгенерируйте пазл');
            return;
        }

        const { width, height } = this.canvas;
        const b = this.imgBounds;
        const strokeWidth = this.state.strokeWidth * CONFIG.MM_TO_PX;
        const isCircular = this.state.type === 'circular';

        let clipDef = '';
        let border = '';

        if (isCircular && this.circleBounds) {
            clipDef = `<circle cx="${this.circleBounds.cx.toFixed(2)}" cy="${this.circleBounds.cy.toFixed(2)}" r="${this.circleBounds.radius.toFixed(2)}"/>`;
            border = `<circle cx="${this.circleBounds.cx.toFixed(2)}" cy="${this.circleBounds.cy.toFixed(2)}" r="${this.circleBounds.radius.toFixed(2)}" stroke-width="${(strokeWidth*1.5).toFixed(2)}"/>`;
        } else {
            clipDef = `<rect x="${b.x.toFixed(2)}" y="${b.y.toFixed(2)}" width="${b.w.toFixed(2)}" height="${b.h.toFixed(2)}"/>`;
            border = `<rect x="${b.x.toFixed(2)}" y="${b.y.toFixed(2)}" width="${b.w.toFixed(2)}" height="${b.h.toFixed(2)}" stroke-width="${(strokeWidth*1.5).toFixed(2)}"/>`;
        }

        let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width.toFixed(0)}" height="${height.toFixed(0)}" viewBox="0 0 ${width.toFixed(0)} ${height.toFixed(0)}">
<defs>
<clipPath id="imgClip">${clipDef}</clipPath>
</defs>
<image href="${this.state.image.src}" x="${b.x.toFixed(2)}" y="${b.y.toFixed(2)}" width="${b.w.toFixed(2)}" height="${b.h.toFixed(2)}" clip-path="url(#imgClip)"/>
<g fill="none" stroke="#000" stroke-width="${strokeWidth.toFixed(2)}" stroke-linejoin="round" stroke-linecap="round">
`;

        this.pieces.forEach(p => {
            svg += `<path d="${p.path}"/>\n`;
        });

        svg += border + '\n';
        svg += `</g>\n</svg>`;

        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `puzzle-${Date.now()}.svg`;
        a.click();
        URL.revokeObjectURL(url);
        this.showToast('SVG сохранён!');
    }

    downloadDXF() {
        if (this.pieces.length === 0) {
            this.showToast('Сначала сгенерируйте пазл');
            return;
        }

        const pxPerMm = CONFIG.MM_TO_PX;
        const hMM = this.canvas.height / pxPerMm;
        const isCircular = this.state.type === 'circular';

        let dxf = `0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1009\n0\nENDSEC\n`;
        dxf += `0\nSECTION\n2\nENTITIES\n`;

        const pathToPoints = (pathStr) => {
            const points = [];
            const cmds = pathStr.match(/[MLZ][^MLZ]*/gi) || [];
            cmds.forEach(cmd => {
                const type = cmd[0].toUpperCase();
                const vals = cmd.slice(1).trim().split(/[\s,]+/).filter(x => x).map(parseFloat);
                if ((type === 'M' || type === 'L') && vals.length >= 2) {
                    points.push({ x: vals[0], y: vals[1] });
                }
            });
            return points;
        };

        const writePolyline = (pts) => {
            if (pts.length < 2) return '';
            let out = `0\nLWPOLYLINE\n8\nPUZZLE_CUT\n90\n${pts.length}\n70\n1\n`;
            pts.forEach(p => {
                out += `10\n${(p.x / pxPerMm).toFixed(4)}\n`;
                out += `20\n${(hMM - p.y / pxPerMm).toFixed(4)}\n`;
            });
            return out;
        };

        this.pieces.forEach(p => {
            dxf += writePolyline(pathToPoints(p.path));
        });

        // Outer border
        if (isCircular && this.circleBounds) {
            const cx = (this.circleBounds.cx / pxPerMm).toFixed(4);
            const cy = (hMM - this.circleBounds.cy / pxPerMm).toFixed(4);
            const r = (this.circleBounds.radius / pxPerMm).toFixed(4);
            dxf += `0\nCIRCLE\n8\nBORDER\n10\n${cx}\n20\n${cy}\n40\n${r}\n`;
        } else {
            const b = this.imgBounds;
            const borderPts = [
                { x: b.x, y: b.y },
                { x: b.x + b.w, y: b.y },
                { x: b.x + b.w, y: b.y + b.h },
                { x: b.x, y: b.y + b.h }
            ];
            dxf += writePolyline(borderPts);
        }

        dxf += `0\nENDSEC\n0\nEOF\n`;

        const blob = new Blob([dxf], { type: 'application/dxf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `puzzle-cnc-${Date.now()}.dxf`;
        a.click();
        URL.revokeObjectURL(url);
        this.showToast('DXF для ЧПУ сохранён!');
    }

    showToast(msg) {
        const el = document.getElementById('toast');
        el.textContent = msg;
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 3000);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    window.puzzleApp = new PuzzleGenerator();
});
</script>
</body>
</html>
